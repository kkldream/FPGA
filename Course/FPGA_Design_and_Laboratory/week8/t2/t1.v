
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module t1(

	//////////// CLOCK //////////
	CLOCK_50,
	CLOCK2_50,
	CLOCK3_50,

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3,
	HEX4,
	HEX5,
	HEX6,
	HEX7,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	GPIO 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;
input 		          		CLOCK2_50;
input 		          		CLOCK3_50;

//////////// LED //////////
output		     [8:0]		LEDG;
output		    [17:0]		LEDR;

//////////// KEY //////////
input 		     [3:0]		KEY;

//////////// SW //////////
input 		    [17:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;
output		     [6:0]		HEX4;
output		     [6:0]		HEX5;
output		     [6:0]		HEX6;
output		     [6:0]		HEX7;

//////////// GPIO, GPIO connect to GPIO Default //////////
inout 		    [35:0]		GPIO;

//=======================================================
//  REG/WIRE declarations
//=======================================================

wire 	clock_1MHz, clock_100ms, clock_10ms, clock_1s;  // clock signal
wire [7:0] t_hour, t_min, t_sec, key_count;
reg [31:0] num;
reg [27:0] counter_1;
wire [27:0] rst_time;
reg stop;
assign LEDR = SW;

assign t_sec[3:0] = num%60%10;
assign t_sec[7:4] = num%60/10;

assign t_min[3:0] = num%3600/60%10;
assign t_min[7:4] = num%3600/60/10;

assign t_hour[3:0] = num%86400/3600%10;
assign t_hour[7:4] = num%86400/3600/10;

assign key_count[3:0] = SW[1:0];
assign key_count[7:4] = SW[2];
//assign num = {key_count, t_hour, t_min, t_sec};
//=======================================================
//  Structural coding
//=======================================================

clock_all uc (
	  .clk(CLOCK_50), 
	  .clock_1MHz(clock_1MHz),
	  .clock_100ms(clock_100ms),
	  .clock_10ms(clock_10ms),
	  .clock_1s(clock_1s)
);

SEG7_LUT_8 useg(
		.iDIG({key_count, t_hour, t_min, t_sec}),
		.oSEG0(HEX0),
		.oSEG1(HEX1),
		.oSEG2(HEX2),
		.oSEG3(HEX3),
		.oSEG4(HEX4),
		.oSEG5(HEX5),
		.oSEG6(HEX6),
		.oSEG7(HEX7)
);

mux4_1 u_rst_time (
		.D0(28'd5000000), .D1(28'd500000), .D2(28'd50000), .D3(28'd5000),  
		.s1(SW[1]), .s0(SW[0]), .Y(rst_time));
defparam u_rst_time.width = 32;
		
wire key0_press, key1_press, key2_press, key3_press;
reg [2:0] key0_dly, key1_dly, key2_dly, key3_dly;
assign key0_press = (key0_dly[2] && !key0_dly[1]) ? 1'b1:1'b0;
assign key1_press = (key1_dly[2] && !key1_dly[1]) ? 1'b1:1'b0;
assign key2_press = (key2_dly[2] && !key2_dly[1]) ? 1'b1:1'b0;
assign key3_press = (key3_dly[2] && !key3_dly[1]) ? 1'b1:1'b0;
always @(posedge CLOCK_50)
begin
	key0_dly <= {key0_dly[1:0], KEY[0]};
	key1_dly <= {key1_dly[1:0], KEY[1]};
	key2_dly <= {key2_dly[1:0], KEY[2]};
	key3_dly <= {key3_dly[1:0], KEY[3]};
	if (key0_press)  num <= 0; 
	if (key1_press)  num <= num + 3600; 
	if (key2_press)  num <= num - 3600; 
	if (key3_press)  stop = (stop == 1 ? 0 : 1); 
	if (counter_1 == 0) begin
		if (stop == 0) num <= num + (SW[2] ? 1 : -1);
		counter_1 <= rst_time;
	end       
	else counter_1 <= counter_1 - 1;
	
end

endmodule
